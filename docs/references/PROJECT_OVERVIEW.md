# 프로젝트 기획서: CUPIA 이벤트 기반 배치 프레임워크 개발

## 1. 프로젝트 개요

* **프로젝트명**: CUPIA 이벤트 기반 배치 프레임워크 개발
* **목표**: 기존의 주기적 배치 기능을 이벤트 기반으로 전환하고, 향후 CUPIA의 모든 도메인에서 재사용 가능한 범용 프레임워크를 구축
* **개발 방법론**: 애자일/스크럼
* **프로젝트 관리**: Jira (초보자용 가이드 포함)

## 2. 기술 스택 및 환경

| 분류 | 기술 스택 | 비고 |
| :--- | :--- | :--- |
| **개발 언어** | Java 21 | 최신 버전 적용 |
| **프레임워크** | Spring Boot, Spring Cloud Streams | Context7 MCP 활용 |
| **빌드 툴** | Gradle | 최신 버전 적용 |
| **메시지 브로커** | Kafka vs. RabbitMQ | 최종 선택 후 결정 (Kafka 우선 검토) |
| **아키텍처 선택** | Spring Batch Job 활용 | 이벤트 리스너가 Job을 호출하는 하이브리드 아키텍처 |

## 3. Jira 기반 프로젝트 진행 가이드

### 3.1. Jira 프로젝트 생성 및 백로그 구성

1.  **프로젝트 생성**: Jira에서 `스크럼(Scrum)` 템플릿 선택 후, 프로젝트명과 키를 입력합니다.
    * **이름**: `CUPIA 이벤트 기반 배치 프레임워크 개발`
    * **키**: `CUPIA_EDPF`
2.  **에픽(Epic) 정의**: 프로젝트의 큰 목표들을 백로그에 생성합니다.
    * `[아키텍처 설계]` 이벤트 기반 프레임워크 핵심 아키텍처 및 공통 모듈 설계
    * `[인프라 구성]` 메시지 브로커 및 인프라 환경 구축
    * `[마이그레이션]` 기존 배치 기능의 이벤트 기반 전환
    * `[운영 관리]` 모니터링, 로깅, 배포 자동화 시스템 구축
3.  **스토리(Story) 및 태스크(Task) 작성**: 각 에픽 아래에 세부 기능과 작업을 추가합니다.

### 3.2. 핵심 아키텍처 선택 (Service vs. Spring Batch vs. BPM)

이벤트 발생 시 비즈니스 로직을 처리하는 방식을 결정합니다.

| 구분 | **Service 클래스** | **Spring Batch Job** | **BPM** |
| :--- | :--- | :--- | :--- |
| **장점** | - 개발 단순성, 경량 | - 강력한 안정성(재시작, 실패 관리) | - 프로세스 시각화, 유연성 |
| **단점** | - 복잡한 작업 관리 어려움 | - 프레임워크 의존성, 초기 비용 | - 높은 학습 곡선, 무거움 |
| **최종 선택** | **Spring Batch Job** | - **이유**: 엔터프라이즈급 안정성 및 재시작 기능이 중요. Spring Cloud Streams와 결합하여 `이벤트 리스너가 Job을 호출`하는 하이브리드 아키텍처 구성. |

### 3.3. 메시지 브로커 선택 (Kafka vs. RabbitMQ)

| 구분 | **Kafka** | **RabbitMQ** |
| :--- | :--- | :--- |
| **강점** | - 대용량 데이터 스트리밍, 높은 처리량, 분산 시스템에 최적 | - 복잡한 메시지 라우팅, 유연한 메시지 전달 |
| **추천** | **Kafka** (대용량 이벤트 스트림 처리에 최적화) | - 메시지 라우팅이 복잡하거나 메시지 전달 순서가 엄격할 때 고려 |

## 4. 용어 사용 가이드

* **공식 프로젝트명**: `CUPIA Event-Driven Processing Framework` (약어: `CUPIA EDPF`)
    * **사용처**: 기술 문서, 코드, Jira 등
* **현업 소통명**: `CUPIA 실시간 배치 처리 시스템`
    * **사용처**: 현업 회의, 보고 등

### **CUPIA Event-Driven Processing Framework 개발 계획**

---

### **📋 확정된 아키텍처 결정**

* **하이브리드 접근법 채택:** `@Service` 기반과 `Spring Batch` 기반의 장점을 모두 활용하는 하이브리드 아키텍처를 채택.
* **초기 개발:** `@Service` 기반의 경량 구현으로 빠르게 시작하여 단순한 이벤트 처리에 집중.
* **점진적 확장:** 복잡한 로직이나 대용량 처리가 필요한 경우, `Spring Batch` 기반 구현체로 전환.
* **프레임워크 투명성:** 사용자는 설정 파일을 통해 원하는 처리 방식을 선택하고, 내부 구현 방식은 추상화하여 투명하게 제공.

---

### **🚀 개발 단계별 계획**

#### **Phase 1: 기반 구조 구축**

1.  **프로젝트 기본 구조 생성**
    * **기술 스택:** Java 21, Spring Boot, Gradle
    * **주요 의존성:** Spring Cloud Streams, Kafka
2.  **핵심 인터페이스 정의**
    * `EventProcessor<T>`: 이벤트 처리 로직을 위한 공통 인터페이스.
    * 이벤트 리스너 (`@EventListener`)를 활용한 Kafka 이벤트 수신 구조 설계.

#### **Phase 2: Simple 구현체 개발**

1.  **`@Service` 기반 `EventProcessor` 구현**
    * `SimpleEventProcessor` 클래스 구현.
    * `@Transactional`을 활용한 트랜잭션 관리 로직 구현.
2.  **설정 기반 선택 시스템**
    * YAML 설정 파일(`application.yml`)에서 `processor.type`을 `simple`로 지정.
    * `ProcessorFactory` 패턴을 적용하여 설정에 따라 적절한 `EventProcessor` 구현체를 주입하도록 구성.

#### **Phase 3: 확장 가능 구조 준비**

1.  **Spring Batch 통합 준비**
    * `BatchEventProcessor` 인터페이스 또는 클래스 설계.
    * `JobLauncher`를 통해 `Spring Batch Job`을 실행하는 연동 구조 준비.
    * `BatchEventProcessor`를 위한 별도 설정 속성 추가 (예: `batch.job-name`).
2.  **프레임워크화**
    * **Auto-configuration:** 사용자가 별도의 설정 없이 의존성 추가만으로 프레임워크를 사용할 수 있도록 자동 구성 로직 개발.
    * **Starter 모듈:** 프로젝트를 모듈화하여 `cupia-edpf-starter`와 같은 형태로 제공.

#### **Phase 4: 테스트 및 문서화**

1.  **통합 테스트**
    * **TestContainers**를 활용하여 Kafka 연동 테스트 환경 구축.
    * `SimpleEventProcessor`와 `BatchEventProcessor` 두 가지 구현체에 대한 동작 검증.
    * 실패 및 재시도 시나리오 테스트.
2.  **사용 가이드 작성**
    * **개발자 가이드 문서:** 프레임워크의 개념, 아키텍처, 사용법 설명.
    * **설정 및 사용법 예제:** `application.yml` 설정 예시와 함께 각 구현체 사용 방법 제공.

---

### **🎯 핵심 설계 원칙**

* **점진적 복잡성:** 단순한 요구사항은 단순한 코드로, 복잡한 요구사항은 점진적으로 확장 가능한 구조로 설계.
* **설정 기반 제어:** 사용자가 코드 변경 없이 설정만으로 프레임워크의 동작 방식을 전환할 수 있도록 유연성을 제공.
* **투명한 추상화:** 내부의 복잡한 구현 세부사항(e.g., Spring Batch 메타데이터)을 숨기고, 사용자에게는 `EventProcessor`라는 명확한 인터페이스만 노출.
* **범용성:** 특정 도메인에 종속되지 않고, 다양한 프로젝트에서 재사용 가능한 범용 프레임워크로 개발.